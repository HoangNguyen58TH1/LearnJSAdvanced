11/09/2020
Task1: Hoisting
- Để  tránh hoisting thì ngta khai báo variable ở đầu function hoặc đầu chương trình.

-----------------------------------------------------------
Task2: Let, Const

1. Declaration (khai báo)
A. Khai báo:
- var thì được khai báo lại
- let, const thì không được khai báo lại.
B. Khai báo mà k gán giá trị:
- var, let có thể khai báo mà không gán gia trị chi nó --> undefined
- const thì không thể khai báo mà k gán giá trị được.

2. Hoisting
- var thì có hoisting còn let, const thì không.

3. Block scope
- let, const thì nó có block scope
- var thì k có block scope, mà chỉ có function scope thôi. --> var k tuân thủ block scope.
- block scope là gì: là khi mình khao báo vs: {}
+ VD: if{...}
      for{...}
      function{...}
      Thậm chí là khai báo như vậy luôn vẫn đc coi là 1 block scope: {...} --> k có if hay for gì. --> nhưng mà thực ra nó k đc dùng bao giờ cả.
      Ngoại trừ khai báo object. {}
- Như vậy thì function scope nó sẽ thuộc váo block scope.

- Thông thường khi lập trình thì ngta càng muốn giới hạn cái scope của variable càng nhỏ càng tốt. --> Vì như vậy:
+ Dể quản lý scope của biến
+ Scope càng bé thì càng ít tốn bộ nhớ khi chạy chương trình.
--> Mục đích là để tối ưu chương trình của mình.

*** Túm lại: let và const được tạo ra để thay thể var. Nhằm khắc phục:
- khai báo lại
- hoisting
- block scope --> tiết kiệm bộ nhớ, tối ưu hóa chương trình.

-----------------------------------------------------------
Task3: Function context & bind
- global context: ngữ cảnh toàn cục
- function context: ngữ cảnh của cái function đó
- bind: methods bind dùng để trói buộc function đó vào 1 cái context gì đó.

-----------------------------------------------------------
Task4: Arrow function expression - Fat arrow
=> ->
- expression: biểu hiện, sự diễn tả.

- Nếu chỉ có 1 param thì không cần ().
- còn nếu không có hoặc từ 2 param trở lên thì phải có dấu ngoặc () mới đúng cú pháp.

-----------------------------------------------------------
Task5: Arrow function expression - part2
- arrow function thì không có context.
- function bình thường, không theo kiểu ES6 thì có context.

- Nếu không viết JS theo kiểu ES6 trở lên thì phải bind(object) nó mới nhận context
- Còn viết theo kiểu ES6 thì arrow function k có context.

- Như vậy là có 3 cách để  dùng lại biến this cho 1 function bên trong 1 function cha.
+ .bind(object)
+ that = this
+ dùng arrow function expression

--- Sư khác biệt giữa arrow function vs function thường ???


-----------------------------------------------------------
Task6: Template String
- `${ trong này viết được các biểu thức JS }`
- Biểu thức JS:
+ tên biến
+ các phép tính cộng trừ nhân chia
+ gọi function
- Ngoài ra dùng cách template string thì có thể  xuống dòng được.
- Chèn 1 lần nhiều biểu thức được.

-----------------------------------------------------------
Task7: Arguments
- tham số
- đối số
- tham số mặc định = giá trị đối số mặc định.

- biến arguments nằm trong all function (ngoài trừ arrow function)
- argunments là 1 object có dang array-like object.
- array-like object không có các method của array.
- 1 array-like object là:
let obj = {
      1: 'Hoang',
      2: 'Nguyen',
      3: 'Van',
      length: 3
}
--> tức là phải có các key như index của array và có property length ở cuối.

- arguments là 1 biến tồn tại bên trong scope của 1 cái function(k phải =>) dưới dạng array-like object.
- arguments tuy k được khai báo nhưng luôn tồn tại trong scope của 1 function.

- Xử lý khi nhận n đối số  đầu vào --> using arguments --> convert into array --> using reduce || map.

-----------------------------------------------------------
Task8: Default parameters 

- const có 1 cái dở hơi đó là khi khai báo object (cả array cũng vậy) thì nó vấn bị change bình thường. 
Chỉ khi khai báo các kiểu như: string, number, boolean thì mới k bị change.

- Default parameters: tham số mặc định của 1 function.

-----------------------------------------------------------
Task8: Call
- bind(object) 
      --> return 1 function và phải gọi function ấy bằng cách thêm ()
- call(object, argument1, argument2, ...) 
- call(this, argument1, argument2, ...) 
      --> gọi function đấy và (return value) mà (function return).
- apply(object, [argument1, argument2, ...])
- apply(this, [argument1, argument2, ...])
      --> nhận vào a array || array-like object.

-----------------------------------------------------------
Task11: Enhanced object literals
- literal: theo nghĩa đen.
- object literals: object được khai báo theo kiểu viết tay. --> {}

- materials: nguyên vật liệu

- hàm ẩn danh (closure).

-----------------------------------------------------------
Task12: Class
- Trước khi có class thì trong JS ngta sử dụng OOP bằng constructor function vs prototype
- constructor: khởi tạo
- constructor function: hàm khởi tạo

- snake: hoang_nguyen
- camelCase: hoangNguyen
- PascalCase: HoangNguyen

- window cho browsers và global cho nodeJS.

- Java là language thuần OOP
- JS không phải là language lập trình HĐT từ ban đầu (k phải language OOP từ đầu)
--> Cú pháp Class được sinh ra để  viết Constructor function ngắn gọn hơn.
--> Giống lagnuage OOP hơn.

-----------------------------------------------------------
Task13: Class Inheritance - Kế  thừa trong class - OOP
- Kế thừa: là 1 đặc điểm trong OOP (lập trình HĐT)
- parrot: con vẹt