11/09/2020
Task1: Hoisting
- Để  tránh hoisting thì ngta khai báo variable ở đầu function hoặc đầu chương trình.

-----------------------------------------------------------
Task2: Let, Const

1. Declaration (khai báo)
A. Khai báo:
- var thì được khai báo lại
- let, const thì không được khai báo lại.
B. Khai báo mà k gán giá trị:
- var, let có thể khai báo mà không gán gia trị chi nó --> undefined
- const thì không thể khai báo mà k gán giá trị được.

2. Hoisting
- var thì có hoisting còn let, const thì không.

3. Block scope
- let, const thì nó có block scope
- var thì k có block scope, mà chỉ có function scope thôi. --> var k tuân thủ block scope.
- block scope là gì: là khi mình khao báo vs: {}
+ VD: if{...}
      for{...}
      function{...}
      Thậm chí là khai báo như vậy luôn vẫn đc coi là 1 block scope: {...} --> k có if hay for gì. --> nhưng mà thực ra nó k đc dùng bao giờ cả.
      Ngoại trừ khai báo object. {}
- Như vậy thì function scope nó sẽ thuộc váo block scope.

- Thông thường khi lập trình thì ngta càng muốn giới hạn cái scope của variable càng nhỏ càng tốt. --> Vì như vậy:
+ Dể quản lý scope của biến
+ Scope càng bé thì càng ít tốn bộ nhớ khi chạy chương trình.
--> Mục đích là để tối ưu chương trình của mình.

*** Túm lại: let và const được tạo ra để thay thể var. Nhằm khắc phục:
- khai báo lại
- hoisting
- block scope --> tiết kiệm bộ nhớ, tối ưu hóa chương trình.

-----------------------------------------------------------
Task3: Function context & bind
- global context: ngữ cảnh toàn cục
- function context: ngữ cảnh của cái function đó
- bind: methods bind dùng để trói buộc function đó vào 1 cái context gì đó.

-----------------------------------------------------------
Task4: Arrow function expression - Fat arrow
=> ->
- expression: biểu hiện, sự diễn tả.

- Nếu chỉ có 1 param thì không cần ().
- còn nếu không có hoặc từ 2 param trở lên thì phải có dấu ngoặc () mới đúng cú pháp.

-----------------------------------------------------------
Task5: Arrow function expression - part2
- arrow function thì không có context.
- function bình thường, không theo kiểu ES6 thì có context.

- Nếu không viết JS theo kiểu ES6 trở lên thì phải bind(object) nó mới nhận context
- Còn viết theo kiểu ES6 thì arrow function k có context.

- Như vậy là có 3 cách để  dùng lại biến this cho 1 function bên trong 1 function cha.
+ .bind(object)
+ that = this
+ dùng arrow function expression

--- Sư khác biệt giữa arrow function vs function thường ???


-----------------------------------------------------------
Task6: Template String
- `${ trong này viết được các biểu thức JS }`
- Biểu thức JS:
+ tên biến
+ các phép tính cộng trừ nhân chia
+ gọi function
- Ngoài ra dùng cách template string thì có thể  xuống dòng được.
- Chèn 1 lần nhiều biểu thức được.

